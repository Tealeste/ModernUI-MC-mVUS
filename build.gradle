plugins {
    id 'maven-publish'
}

ext.modernUiMcProfiles = [
        '1.21.9' : [
                modVersionBase           : '3.12.0.5-build.3',
                forge                   : '59.0.5',
                neoforge                : '21.9.16-beta',
                fabricLoader            : '0.18.1',
                fabricApi               : '0.134.1+1.21.9',
                modMenu                 : '16.0.0-rc.2',
                forgeConfigApiPortFabric: '21.9.7',
        ],
        '1.21.10': [
                modVersionBase           : '3.12.0.5-build.3',
                forge                   : '60.1.5',
                neoforge                : '21.10.64',
                fabricLoader            : '0.18.1',
                fabricApi               : '0.138.4+1.21.10',
                modMenu                 : '16.0.0-rc.2',
                forgeConfigApiPortFabric: '21.10.1',
        ],
        '1.21.11': [
                modVersionBase           : '3.12.0.5-build.3',
                forge                   : '61.0.3',
                neoforge                : '21.11.17-beta',
                fabricLoader            : '0.18.1',
                fabricApi               : '0.140.2+1.21.11',
                modMenu                 : '17.0.0-beta.1',
                forgeConfigApiPortFabric: '21.11.1',
        ],
        '26.1-snapshot-1': [
                modVersionBase           : '3.12.0.5-build.3',
                // NOTE: Forge/NeoForge support for 26.1 snapshots is not available in this repo yet.
                fabricLoader            : '0.18.4',
                fabricApi               : '0.141.3+26.1',
                modMenu                 : '18.0.0-alpha.4',
                forgeConfigApiPortFabric: '21.11.1',
        ],
]

ext.modernUiMcTarget = (findProperty('minecraft_version') ?: '26.1-snapshot-1') as String
def parseMcTarget = { String mcVersion ->
    def legacy = (mcVersion =~ /^(\d+)\.(\d+)\.(\d+)$/)
    if (legacy.matches()) {
        return [
                scheme: 'legacy',
                major : legacy[0][1] as int,
                minor : legacy[0][2] as int,
                patch : legacy[0][3] as int,
        ]
    }

    def snapshot = (mcVersion =~ /^(\d+)\.(\d+)-snapshot-(\d+)$/)
    if (snapshot.matches()) {
        return [
                scheme: 'snapshot',
                major : snapshot[0][1] as int,
                minor : snapshot[0][2] as int,
                patch : snapshot[0][3] as int, // snapshot number
        ]
    }

    return [scheme: 'unknown']
}

if (!ext.modernUiMcProfiles.containsKey(ext.modernUiMcTarget)) {
    def supportedMcVersions = ext.modernUiMcProfiles.keySet().toList().sort { a, b ->
        def pa = parseMcTarget(a)
        def pb = parseMcTarget(b)
        if (pa.scheme == 'unknown' || pb.scheme == 'unknown') {
            return a <=> b
        }

        def c0 = pa.major <=> pb.major
        if (c0 != 0) {
            return c0
        }
        def c1 = pa.minor <=> pb.minor
        if (c1 != 0) {
            return c1
        }
        pa.patch <=> pb.patch
    }
    throw new GradleException(
            "Unsupported minecraft_version='${ext.modernUiMcTarget}'. Supported: ${supportedMcVersions.join(', ')}. " +
                    "Use -Pminecraft_version=<version> or update ext.modernUiMcProfiles."
    )
}
ext.modernUiMcProfile = ext.modernUiMcProfiles[ext.modernUiMcTarget]

def mcTargetInfo = parseMcTarget(ext.modernUiMcTarget)
ext.modernUiMcTargetInfo = mcTargetInfo
ext.modernUiJavaRelease = mcTargetInfo.scheme == 'snapshot' ? 25 : 21
if (mcTargetInfo.scheme == 'legacy') {
    ext.modernUiMcTargetNext = "${mcTargetInfo.major}.${mcTargetInfo.minor}.${mcTargetInfo.patch + 1}"
} else if (mcTargetInfo.scheme == 'snapshot') {
    ext.modernUiMcTargetNext = "${mcTargetInfo.major}.${mcTargetInfo.minor}-snapshot-${mcTargetInfo.patch + 1}"
} else {
    throw new GradleException(
            "Invalid minecraft_version='${ext.modernUiMcTarget}'. Supported formats: " +
                    "<major>.<minor>.<patch> (e.g. 1.21.11) or <year>.<cycle>-snapshot-<n> (e.g. 26.1-snapshot-1)"
    )
}
ext.modernUiMcVersionRangeFabric = ">=${ext.modernUiMcTarget} <${ext.modernUiMcTargetNext}"
ext.modernUiMcVersionRangeToml = "[${ext.modernUiMcTarget}, ${ext.modernUiMcTargetNext})"
ext.modernUiForgeFmlMajor = ext.modernUiMcProfile.forge == null ? null : (ext.modernUiMcProfile.forge as String).tokenize('.')[0]
ext.modernUiFabricApiMin = (ext.modernUiMcProfile.fabricApi as String).tokenize('+')[0]

def modVersionBase = (ext.modernUiMcProfile.modVersionBase ?: findProperty('mod_version_base') ?: findProperty('mod_version')) as String
if (!modVersionBase) {
    throw new GradleException("Missing 'mod_version_base' in gradle.properties (e.g. mod_version_base=3.12.0.5-build.3)")
}
def mcSuffixIndex = modVersionBase.indexOf('+mc')
if (mcSuffixIndex != -1) {
    modVersionBase = modVersionBase.substring(0, mcSuffixIndex)
}
ext.mod_version = "${modVersionBase}+mc${ext.modernUiMcTarget}"
ext.forge_version = ext.modernUiMcProfile.forge
ext.neoforge_version = ext.modernUiMcProfile.neoforge

publishing {
    repositories {
        maven {
            name = 'IzzelAliz'
            url = 'https://maven.izzel.io/releases'
            credentials {
                username = project.findProperty("maven_user")
                password = project.findProperty("izzel_maven_token")
            }
        }
    }
}

allprojects {
    apply plugin: 'java'

    group = 'icyllis.modernui'

    java.toolchain.languageVersion = JavaLanguageVersion.of(rootProject.modernUiJavaRelease as int)

    repositories {
        // Mojang-hosted artifacts (e.g., LWJGL *-natives-*-patch)
        maven { url = 'https://libraries.minecraft.net/' }
        mavenCentral()
        if ((rootProject.findProperty('useMavenLocal') ?: 'false').toString().toBoolean()) {
            mavenLocal()
        }
    }

    dependencies {
        compileOnly 'com.google.code.findbugs:jsr305:3.0.2'
        compileOnly 'org.jetbrains:annotations:23.1.0'
        testCompileOnly 'com.google.code.findbugs:jsr305:3.0.2'
        testCompileOnly 'org.jetbrains:annotations:23.1.0'

        def lwjglNatives
        switch (org.gradle.internal.os.OperatingSystem.current()) {
            case org.gradle.internal.os.OperatingSystem.WINDOWS:
                def osArch = System.getProperty("os.arch")
                lwjglNatives = osArch.contains("64")
                        ? "natives-windows${osArch.startsWith("aarch64") ? "-arm64" : ""}"
                        : "natives-windows-x86"
                break
            case org.gradle.internal.os.OperatingSystem.MAC_OS:
                lwjglNatives = System.getProperty("os.arch").startsWith("aarch64") ? "natives-macos-arm64" : "natives-macos"
                break
            default:
                def osArch = System.getProperty("os.arch")
                lwjglNatives = osArch.startsWith("arm") || osArch.startsWith("aarch64")
                        ? "natives-linux-${osArch.contains("64") || osArch.startsWith("armv8") ? "arm64" : "arm32"}"
                        : "natives-linux"
                break
        }

        implementation platform("org.lwjgl:lwjgl-bom:${lwjgl_version}")

        implementation "org.lwjgl:lwjgl"
        implementation "org.lwjgl:lwjgl-glfw"
        implementation "org.lwjgl:lwjgl-jemalloc"
        implementation "org.lwjgl:lwjgl-openal"
        implementation "org.lwjgl:lwjgl-opengl"
        implementation "org.lwjgl:lwjgl-stb"
        implementation "org.lwjgl:lwjgl-tinyfd"
        implementation "org.lwjgl:lwjgl-vma"
        implementation "org.lwjgl:lwjgl-vulkan"
        runtimeOnly "org.lwjgl:lwjgl::$lwjglNatives"
        runtimeOnly "org.lwjgl:lwjgl-glfw::$lwjglNatives"
        runtimeOnly "org.lwjgl:lwjgl-jemalloc::$lwjglNatives"
        runtimeOnly "org.lwjgl:lwjgl-openal::$lwjglNatives"
        runtimeOnly "org.lwjgl:lwjgl-opengl::$lwjglNatives"
        runtimeOnly "org.lwjgl:lwjgl-stb::$lwjglNatives"
        runtimeOnly "org.lwjgl:lwjgl-tinyfd::$lwjglNatives"
        runtimeOnly "org.lwjgl:lwjgl-vma::$lwjglNatives"
        if (lwjglNatives == "natives-macos" || lwjglNatives == "natives-macos-arm64") {
            runtimeOnly "org.lwjgl:lwjgl-vulkan::$lwjglNatives"
        }
    }

    tasks.withType(JavaCompile).configureEach {
        it.options.encoding = "UTF-8"
        it.options.release.set(rootProject.modernUiJavaRelease as int)
    }

    java {
        withSourcesJar()
    }

    tasks.withType(org.gradle.api.tasks.bundling.AbstractArchiveTask).configureEach {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }
}

def releaseDir = layout.buildDirectory.dir("release")
def releaseModVersion = mod_version

def fabricProject = project(':ModernUI-Fabric')
def forgeProject = project(':ModernUI-Forge')
def neoForgeProject = project(':ModernUI-NeoForge')
def supportsForge = rootProject.modernUiMcProfile.forge != null
def supportsNeoForge = rootProject.modernUiMcProfile.neoforge != null

def fabricUniversalJar = fabricProject.layout.buildDirectory.file("libs/${fabricProject.name}-${releaseModVersion}-universal.jar")
def forgeUniversalJar = forgeProject.layout.buildDirectory.file("libs/${forgeProject.name}-${releaseModVersion}-universal.jar")
def neoForgeUniversalJar = neoForgeProject.layout.buildDirectory.file("libs/${neoForgeProject.name}-${releaseModVersion}-universal.jar")

tasks.register('syncReleaseJars', Sync) {
    group = 'distribution'
    description = 'Builds and collects distributable jars into build/release.'

    def remapJarTasks = [
            ':ModernUI-Fabric:remapJar',
    ]
    if (supportsForge) {
        remapJarTasks.add(':ModernUI-Forge:remapJar')
    }
    if (supportsNeoForge) {
        remapJarTasks.add(':ModernUI-NeoForge:remapJar')
    }
    dependsOn(remapJarTasks)

    into(releaseDir)

    from(fabricUniversalJar) {
        rename { "${rootProject.name}-${releaseModVersion}-fabric.jar" }
    }
    if (supportsForge) {
        from(forgeUniversalJar) {
            rename { "${rootProject.name}-${releaseModVersion}-forge.jar" }
        }
    }
    if (supportsNeoForge) {
        from(neoForgeUniversalJar) {
            rename { "${rootProject.name}-${releaseModVersion}-neoforge.jar" }
        }
    }

    doFirst {
        def expectedJars = [
                fabricUniversalJar.get().asFile,
        ]
        if (supportsForge) {
            expectedJars.add(forgeUniversalJar.get().asFile)
        }
        if (supportsNeoForge) {
            expectedJars.add(neoForgeUniversalJar.get().asFile)
        }
        expectedJars.each { File jarFile ->
            if (!jarFile.exists()) {
                throw new GradleException("Expected release jar was not produced: ${jarFile}")
            }
        }
    }
}

tasks.register('buildReleaseJars') {
    group = 'build'
    description = 'One-command build for distributable Fabric/Forge/NeoForge jars.'
    dependsOn('syncReleaseJars')
}
